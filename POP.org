#+TITLE: The Practice of Programming
#+TAGS: OK BeyondMyLevel Caution
#+STARTUP: overview
* スタイル
** 名前
*** グローバルにはわかりやすい名前を，ローカルには短い名前を
慣習に従うと，短くできることがある．
ループ変数i, j, ポインタのp, qなど．
*** 統一しよう
1つの概念には1つの用語を使うべき．
*** 関数には能動的な名前を
返り値が明確になるような名前もいい．isoctal()など．
*** 名前は的確に
**** 問題1-1
次のコードの名前と値の選び方についてコメントせよ
#+BEGIN_SRC C
  #define TRUE 0
  #define FALSE 1
  if ((ch = getchar()) == EOF)
      not_eof = FALSE;
#+END_SRC
TRUEとFALSEの値を逆にし，not_eofをis_eofにしたほうがよい．
**** 問題1-2
次の関数を改良せよ
#+BEGIN_SRC C
  int smaller (char *s, char *t) {
      if (strcmp(s, t) < 1)
          return 1;
      else
          return 0;
  }
#+END_SRC
strcmp(a, b)は，aがbより大きければ正の整数値，aがbより小さければ負の整数値，等しければ0を返す．
関数の名前を正しくするにはsmaller_or_equalとなるが，長いので，biggerとしてはどうか．
#+BEGIN_SRC C
  int bigger (char *s, char *t) {
      if (strcmp(s, t) > 0)
          return 1;
      else
          return 0;
  }
#+END_SRC
**** 問題1-3
次のコードを音読せよ
#+BEGIN_SRC C
  if ((falloc(SMRHSHSCRTCH, S_IFEXT | 0644, MAXRODDHSH)) < 0)
      ...
#+END_SRC
むりむり．
** 式と文
*** 構造がわかるようにインデントしよう
*** 自然な形の式を使おう
否定が入っていると分かりづらくなるのでなるべく避ける
*** 括弧を使ってあいまいさを解消しよう
見かけは
if (x&MASK == BITS)
と書いてあっても，
実際には
if (x & (MASK == BITS))
と評価されてしまう．
意図を正しく伝えるために括弧を書けば，これを避けられる．
*** 複雑な式は分割しよう
式の構文や演算子が充実しているからといって，調子にのって短く書きすぎるな．
#+BEGIN_SRC C
  ,*x += (*xp = (2*k < (n-m) ? c[k+1] : d[k--])); /* いくら正しくても，理解しにくい */

  /* こう書けば，わかりやすい */
  if (2*k < n-m)
      ,*xp = c[k+1];
  else
      ,*xp = d[k--];
  ,*x += *xp;
#+END_SRC
*** 明解に書こう
明快さは，短さと同義ではない．
明解に書いた結果，コードは短くなることもあれば，長くなることもある．
*** 副作用に注意
++など，副作用を持った演算子には注意が必要．
表示と，値の更新が同時に実行されるとは限らないため．
str[i++] = str[i++] = '';
と，多重代入するのは危険．
おとなしく2回に分けて，
str[i++] =  '';
str[i++] =  '';
と書くべき．
scanf("%d %d", &yr, &profit[yr]);
も，意図した結果になることは決してない．
コンパイルした段階で全ての値が評価されるので，profit[yr]はscanfで読み込む前の古いyrの値を使う．
**** 問題1-4
次のそれそれのコードを改良せよ
#+BEGIN_SRC C
  /* 改良前 */
  if (!(c == 'y' || c == 'Y'))
      return;
  /* 改良後 */
  if ((c != 'y' && c != 'Y'))
      return;

  /* 改良前 */
  length = (length < BUFSIZE) ? length : BUFSIZE;
  /* 改良後 */
  if (length < BUFSIZE)
      length = length;
  else
      length = BUFSIZE;

  /* 改良前 */
  flag = flag ? 0 : 1;
  /* 改良後 */
  if (flag != 0)
      flag = 1;

  /* 改良前 */
  quote = (*line == '"') ? 1 : 0;
  /* 改良後 */
  if (*line == '"')
      isquote = 1;
  else
      isquote = 0;

  /* 改良前 */
  if (val & 1)
      bit = 1;
  else
      bit = 0;
  /* 改良後 */
  if (val == 0)
      bit = 0;
  else
      bit = 1;
#+END_SRC
**** 問題1-5
次の部分の問題点は何か
#+BEGIN_SRC C
  int read(int *ip) {             /* ipがまだ代入されていないうちにポインタが呼ばれていることが問題 */
      scanf("%d", ip);
      return *ip;
  }

  insert(&graph[vert], read[&val], read(&ch));
#+END_SRC

**** 問題1-6
さまざまな評価順によって生成される可能性のある出力をすべて列挙せよ
#+BEGIN_SRC C
  #include <stdio.h>

  int main(void){
      int n = 1;
      printf("%d %d\n", n++, n++);
      return 0;
  }
#+END_SRC
- 1, 2 <- gccではエラーもでた．
- 2, 2
- 2, 3
- 変な値が2つ

** 一貫性と慣用句
*** 一貫性
一貫していれば，準拠するスタイル自体はあまり問題ない（けど，本書のものに従うのが得策）．
複数のif文とelse文が同時に出てくるときには，ブレースを絶対に省略してはいけない．
他人の書いたプログラムを修正するときには，そのプログラムのスタイルに従うこと．
いくら気に入っていても，自分のスタイルを使ったりしないように．

*** 慣用句
慣習に従えば，慣習に従っていないところが目立ちやすくなる．
そこがトラブルの兆候を示しているケースはよくある．

例えば，ループの慣用形式は以下．
for (i = 0; i < n; i++)
    array[i] = 1.0;

リストをたどるなら
for (p = list; p != NULL; p = p->next)

do-whileはバグの絶好のすみかになりやすい．
do-whileでないとならない時以外，絶対に使わないこと．

**** getsは絶対に使ってはならない                          :BeyondMyLevel:
セキュリティの問題につながる

**** 多分岐の判定にはelse ifを使おう
*if文がネストされてならんでいるのは，具合の悪いプログラムの兆候！*

**** case文で落下シーケンスを使うのはやめよう．
各ケースはみなbreakで終わるのが基本．
落下を使うのが許されるのは，数個のcaseに全く同一のコードが使われる時．
#+BEGIN_SRC C
case '0':
case '1':
case '2':
    ...
    break;
#+END_SRC
コメントは一切いらない．

**** 問題1-7
以下のC/C++のコードをもっと明快に書き直せ．
***** コード1
****** Before
#+BEGIN_SRC C
  if (istty(stdin)) ;
  else if (istty(stdout)) ;
       else if (istty(stderr)) ;
            else return(0);
#+END_SRC

****** After
#+BEGIN_SRC C
  if (istty(stdin)) {

  } else if (istty(stdout)) {

  } else if (istty(stderr)) {

  } else {
      return(0);
  }
#+END_SRC
***** コード2
****** Before
#+BEGIN_SRC C
  if (retval != SUCCESS)
  {
      return (retval);
  }
  /* All went well! */
  return SUCCESS;
#+END_SRC
****** After
#+BEGIN_SRC C
  if (retval == SUCCESS) {
      retval = SUCCESS;
  }
  return retval;
#+END_SRC
***** コード3
****** Before
#+BEGIN_SRC C
  for (k = 0; k++ < 5; x += dx)
  scanf("%lf", &dx);
#+END_SRC
****** After
#+BEGIN_SRC C
  for (k = 0; k < 5; k++) {
      scanf("%lf", &dx);
      x += dx;
  }
#+END_SRC

**** 問題1-8
次のJavaコードの間違いを見つけて，慣用句的なループを使って書き直せ．
***** Before
#+BEGIN_SRC java
  int count = 0;
  while (count < total) {
      count++;
      if (this.getName(count) == nametable.userName()) {
          return (true);
      }
  }
#+END_SRC
***** After
#+BEGIN_SRC java
  int count = 0;
  while (this.getName(count) != nametable.userName()) {
      count++;
  }
#+END_SRC
** 関数マクロ
*** 関数マクロはなるべく使うな！
短所が長所を上回ってしまっている
関数マクロの定義の中で，パラメータが2回出てくるとき（下の例のc）に，悪夢が起こる．
#+BEGIN_SRC C
# define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#+END_SRC
このisupperが以下のような文脈で呼ばれると大変．
#+BEGIN_SRC C
while (isupper(c = getchar()))
#+END_SRC
そもそもgetchar()などはネストしない方がいい．
*** マクロの本体と引数は括弧に入れよう．
マクロはただのテキスト置換なので，括弧を使っておかないと数学的におかしいことになったりする．
#define square (x) (x) * (x)
と書いたあとで，
1 / square(x)
として使用すると，
1 / (x) * (x)
となる．恐ろしい．
正しくは，
#define square (x) ((x) * (x))
ちゃんと書いたとしても，多重評価の問題は残る．
使わないに越したことはない．

C++なら，インライン関数
*** 問題1-9
次のマクロ定義の問題点を指摘せよ．
#+BEGIN_SRC C
# define ISDIGIT(c) ((c >= '0') && (c <= '9')) ? 1 : 0
#+END_SRC
マクロ内でcが多重評価されている．
例えば，0以上の数が入力されるたびにそれが捨てられ，新しい数が9と比較されることになる．
** マジックナンバー
*** マジックナンバーには名前をつけよう
*** 数値はマクロではなく定数として定義しよう
#defineを使うなということ．
Cのプリプロセッサは強力だが乱暴なツール
マクロはプログラムの字句構造を無残に変更してしまう（どういう意味だろう？）危険なプログラミング手段．
- Cならenum
- C++ならconst
- Javaならfinal
*** 整数ではなく文字定数を使おう
if (c >= 65 && c <= 90)　だと，特定の文字表現方式に完全に依存してしまう．
if (c >= 'A' && c <= 'Z')　のほうがまし．

一番いいのは， if (isupper(c)) のように，ライブラリを使うこと．
**** 0の使い方にも注意を払え
0とするのは，本当にリテラルの整数ゼロを意味するときまでとっておけ．
- ゼロのポインタを意図するなら str = 0; ではなく str = NULL;
- ヌルバイトを意図するなら name[i] = 0; ではなく name = '\0'
- 実数のゼロを意図するなら x = 0; ではなく x = 0.0;
*** オブジェクトサイズは言語に計算させよう                  :BeyondMyLevel:
**** 問題1-10
潜在的な間違いを最小限に食い止めるには，次の定義をどのように書き直すべきか．
#+BEGIN_SRC C
#define FT2METER  0.3048
#define METER2FT  3.29084
#define MI2FT     5280.0
#define MI2KM     1.609344
#define SQMI2SQKM 2.589988
#+END_SRC
多分，#defineではなく，enumを使えということだと思う．
** コメント
*** 削除すべきコメント
- コードを見ればひと目でわかることをわざわざ書いている
- コードと矛盾している
- 見た目に凝りすぎて読み手の注意を削いでしまう

*** どんなときにコメントを書くべきか
- 関数
- グローバル変数
- 定数定義
- 構造体とクラスのフィールド

そのほか，
- アルゴリズムが難解
- データ構造が入り組んでいる
など，コードが（うまく書いてあるけど）本当の意味で難解なときには，コメントがあると有効．
こんなときに書いたほうがいい内容は
- 使われるデータ
- アルゴリズムの性能
- 元のアルゴリズムの修正
- 参考文献
など．

*** 教訓
優れたコードは，悪いコードに比べてコメントが少なくて済む．
**** 悪いコードはコメントをつけるのではなく，コード自体を書き直せ
- 否定演算はわかりにくい
- 役に立たない変数名

**** コードと矛盾させるな
書かれたまんまほったらかしで，コードの内容と矛盾しているコメントが最悪．
- 誤解のもと
- デバック作業が長引く

**** コードと一致させるだけでなく，コードに沿わせろ
「なぜここにそのコードを書く必要があるのか」を書け

**** 問題 1-11
以下のコメントについてコメントせよ．

***** before
#+BEGIN_SRC java
  void dict::insert(string& w)
  // w が辞書にあれば1を，なければ0を返す

  if (n > MAX || n % 2 > 0 )  // 偶数のテスト

  // メッセージを出力
  // 1行出力するたびに行カウンタを加算

  void write_message()
  {
      // カウンタをインクリメント
      line_number = line_number + 1;
      fprintf(fout, "%d %s\n%d %s\n%d %s\n",
              line_number, HEADER,
              line_number + 1, BODY,
              line_number + 2, TRAILER);
      // 行カウンタをインクリメント
      line_number = line_number + 2
  }
#+END_SRC

- 何をするためのコードなのか，全然わからない
- インクリメントが + 1だったり+2だったり，本当にこれでいいのかわからない．
- 「メッセージを出力」はいらない

***** TODO after
Javaがわからないのでなんとも．
#+BEGIN_SRC java
  void dict::insert(string& w)
  // w が辞書にあれば1を，なければ0を返す

  if (n > MAX || n % 2 > 0 )  // 偶数のテスト

  // メッセージを出力
  // 1行出力するたびに行カウンタを加算

  void write_message()
  {
      // カウンタをインクリメント
      line_number = line_number + 1;
      fprintf(fout, "%d %s\n%d %s\n%d %s\n",
              line_number, HEADER,
              line_number + 1, BODY,
              line_number + 2, TRAILER);
      // 行カウンタをインクリメント
      line_number = line_number + 2
  }
#+END_SRC
** なぜ手間をかけるのか
バグの温床になるから．
きれいなコードを書く習慣，頭を整理してよいプログラムを書く習慣が身につくから．
** 参考文献
- "The Elements of Style" by Strunk & White <- 英語の上手な書き方！！
- "プログラム書法" by Brian W. Kernighan <- スタイルの方向性？
- "Writing Solid Code" by Steve Maguire <- プログラミングの参考になる話
- "Code Complete" by Steve McConnell
- "エキスパートCプログラミング: 知られざるCの深層" by Peter van der Linden

* アルゴリズムとデータ構造

** 探索

** ソーティング

** ライブラリ

** Java 版クイックソート

** O 記法

** 配列の伸長

** リスト

** ツリー

** ハッシュテーブル

** まとめ

** 参考文献
* 設計と実装
* インターフェイス
* デバッグ
* テスト
* 性能
* 移植性
* 記法
