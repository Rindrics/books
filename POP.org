#+TITLE: The Practice of Programming
#+TAGS: OK BeyondMyLevel Caution
* スタイル
** 名前
*** グローバルにはわかりやすい名前を，ローカルには短い名前を
慣習に従うと，短くできることがある．
ループ変数i, j, ポインタのp, qなど．
*** 統一しよう
1つの概念には1つの用語を使うべき．
*** 関数には能動的な名前を
返り値が明確になるような名前もいい．isoctal()など．
*** 名前は的確に
**** 問題1-1
次のコードの名前と値の選び方についてコメントせよ
#+BEGIN_SRC C
  #define TRUE 0
  #define FALSE 1
  if ((ch = getchar()) == EOF)
      not_eof = FALSE;
#+END_SRC
TRUEとFALSEの値を逆にし，not_eofをis_eofにしたほうがよい．
**** 問題1-2
次の関数を改良せよ
#+BEGIN_SRC C
  int smaller (char *s, char *t) {
      if (strcmp(s, t) < 1)
          return 1;
      else
          return 0;
  }
#+END_SRC
strcmp(a, b)は，aがbより大きければ正の整数値，aがbより小さければ負の整数値，等しければ0を返す．
関数の名前を正しくするにはsmaller_or_equalとなるが，長いので，biggerとしてはどうか．
#+BEGIN_SRC C
  int bigger (char *s, char *t) {
      if (strcmp(s, t) > 0)
          return 1;
      else
          return 0;
  }
#+END_SRC
**** 問題1-3
次のコードを音読せよ
#+BEGIN_SRC C
  if ((falloc(SMRHSHSCRTCH, S_IFEXT | 0644, MAXRODDHSH)) < 0)
      ...
#+END_SRC
むりむり．
** 式と文
*** 構造がわかるようにインデントしよう
*** 自然な形の式を使おう
否定が入っていると分かりづらくなるのでなるべく避ける
*** 括弧を使ってあいまいさを解消しよう
見かけは
if (x&MASK == BITS)
と書いてあっても，
実際には
if (x & (MASK == BITS))
と評価されてしまう．
意図を正しく伝えるために括弧を書けば，これを避けられる．
*** 複雑な式は分割しよう
式の構文や演算子が充実しているからといって，調子にのって短く書きすぎるな．
#+BEGIN_SRC C
  ,*x += (*xp = (2*k < (n-m) ? c[k+1] : d[k--])); /* いくら正しくても，理解しにくい */

  /* こう書けば，わかりやすい */
  if (2*k < n-m)
      ,*xp = c[k+1];
  else
      ,*xp = d[k--];
  ,*x += *xp;
#+END_SRC
*** 明解に書こう
明快さは，短さと同義ではない．
明解に書いた結果，コードは短くなることもあれば，長くなることもある．
*** 副作用に注意
++など，副作用を持った演算子には注意が必要．
表示と，値の更新が同時に実行されるとは限らないため．
str[i++] = str[i++] = '';
と，多重代入するのは危険．
おとなしく2回に分けて，
str[i++] =  '';
str[i++] =  '';
と書くべき．
scanf("%d %d", &yr, &profit[yr]);
も，意図した結果になることは決してない．
コンパイルした段階で全ての値が評価されるので，profit[yr]はscanfで読み込む前の古いyrの値を使う．
**** 問題1-4
次のそれそれのコードを改良せよ
#+BEGIN_SRC C
  /* 改良前 */
  if (!(c == 'y' || c == 'Y'))
      return;
  /* 改良後 */
  if ((c != 'y' && c != 'Y'))
      return;

  /* 改良前 */
  length = (length < BUFSIZE) ? length : BUFSIZE;
  /* 改良後 */
  if (length < BUFSIZE)
      length = length;
  else
      length = BUFSIZE;

  /* 改良前 */
  flag = flag ? 0 : 1;
  /* 改良後 */
  if (flag != 0)
      flag = 1;

  /* 改良前 */
  quote = (*line == '"') ? 1 : 0;
  /* 改良後 */
  if (*line == '"')
      isquote = 1;
  else
      isquote = 0;

  /* 改良前 */
  if (val & 1)
      bit = 1;
  else
      bit = 0;
  /* 改良後 */
  if (val == 0)
      bit = 0;
  else
      bit = 1;
#+END_SRC
**** 問題1-5
次の部分の問題点は何か
#+BEGIN_SRC C
  int read(int *ip) {             /* ipがまだ代入されていないうちにポインタが呼ばれていることが問題 */
      scanf("%d", ip);
      return *ip;
  }

  insert(&graph[vert], read[&val], read(&ch));
#+END_SRC

**** 問題1-6
さまざまな評価順によって生成される可能性のある出力をすべて列挙せよ
#+BEGIN_SRC C
  #include <stdio.h>

  int main(void){
      int n = 1;
      printf("%d %d\n", n++, n++);
      return 0;
  }
#+END_SRC
- 1, 2 <- gccではエラーもでた．
- 2, 2
- 2, 3
- 変な値が2つ

** 一貫性と慣用句
*** 一貫性
一貫していれば，準拠するスタイル自体はあまり問題ない（けど，本書のものに従うのが得策）．
複数のif文とelse文が同時に出てくるときには，ブレースを絶対に省略してはいけない．
他人の書いたプログラムを修正するときには，そのプログラムのスタイルに従うこと．
いくら気に入っていても，自分のスタイルを使ったりしないように．

*** 慣用句
慣習に従えば，慣習に従っていないところが目立ちやすくなる．
そこがトラブルの兆候を示しているケースはよくある．

例えば，ループの慣用形式は以下．
for (i = 0; i < n; i++)
    array[i] = 1.0;

リストをたどるなら
for (p = list; p != NULL; p = p->next)

do-whileはバグの絶好のすみかになりやすい．
do-whileでないとならない時以外，絶対に使わないこと．

**** getsは絶対に使ってはならない                          :BeyondMyLevel:
セキュリティの問題につながる

**** 多分岐の判定にはelse ifを使おう
*if文がネストされてならんでいるのは，具合の悪いプログラムの兆候！*

**** case文で落下シーケンスを使うのはやめよう．
各ケースはみなbreakで終わるのが基本．
落下を使うのが許されるのは，数個のcaseに全く同一のコードが使われる時．
#+BEGIN_SRC C
case '0':
case '1':
case '2':
    ...
    break;
#+END_SRC
コメントは一切いらない．

**** 問題1-7
以下のC/C++のコードをもっと明快に書き直せ．
***** コード1
****** Before
#+BEGIN_SRC C
  if (istty(stdin)) ;
  else if (istty(stdout)) ;
       else if (istty(stderr)) ;
            else return(0);      
#+END_SRC

****** After
#+BEGIN_SRC C
  if (istty(stdin)) {

  } else if (istty(stdout)) {

  } else if (istty(stderr)) {

  } else {
      return(0);
  }
#+END_SRC
***** コード2
****** Before
#+BEGIN_SRC C
  if (retval != SUCCESS)
  {
      return (retval);
  }
  /* All went well! */
  return SUCCESS;
#+END_SRC
****** After
#+BEGIN_SRC C
  if (retval == SUCCESS) {
      retval = SUCCESS;
  }
  return retval;
#+END_SRC
***** コード3
****** Before
#+BEGIN_SRC C
  for (k = 0; k++ < 5; x += dx)
  scanf("%lf", &dx);
#+END_SRC
****** After
#+BEGIN_SRC C
  for (k = 0; k < 5; k++) {
      scanf("%lf", &dx);
      x += dx;
  }
#+END_SRC

**** 問題1-8
次のJavaコードの間違いを見つけて，慣用句的なループを使って書き直せ．
***** Before
#+BEGIN_SRC java
  int count = 0;
  while (count < total) {
      count++;
      if (this.getName(count) == nametable.userName()) {
          return (true);
      }
  }
#+END_SRC
***** After
#+BEGIN_SRC java
  int count = 0;
  while (this.getName(count) != nametable.userName()) {
      count++;
  }
#+END_SRC
** TODO 関数マクロ
** マジックナンバー
** コメント
** なぜ手間をかけるのか
** 参考文献
* アルゴリズムとデータ構造
* 設計と実装
* インターフェイス
* デバッグ
* テスト
* 性能
* 移植性
* 記法
