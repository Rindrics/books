#+TITLE: The Practice of Programming
#+TAGS: OK BeyondMyLevel Caution
#+STARTUP: overview
* スタイル
** 名前
*** グローバルにはわかりやすい名前を，ローカルには短い名前を
慣習に従うと，短くできることがある．
ループ変数i, j, ポインタのp, qなど．
*** 統一しよう
1つの概念には1つの用語を使うべき．
*** 関数には能動的な名前を
返り値が明確になるような名前もいい．isoctal()など．
*** 名前は的確に
**** 問題1-1
次のコードの名前と値の選び方についてコメントせよ
#+BEGIN_SRC C
  #define TRUE 0
  #define FALSE 1
  if ((ch = getchar()) == EOF)
      not_eof = FALSE;
#+END_SRC
TRUEとFALSEの値を逆にし，not_eofをis_eofにしたほうがよい．
**** 問題1-2
次の関数を改良せよ
#+BEGIN_SRC C
  int smaller (char *s, char *t) {
      if (strcmp(s, t) < 1)
          return 1;
      else
          return 0;
  }
#+END_SRC
strcmp(a, b)は，aがbより大きければ正の整数値，aがbより小さければ負の整数値，等しければ0を返す．
関数の名前を正しくするにはsmaller_or_equalとなるが，長いので，biggerとしてはどうか．
#+BEGIN_SRC C
  int bigger (char *s, char *t) {
      if (strcmp(s, t) > 0)
          return 1;
      else
          return 0;
  }
#+END_SRC
**** 問題1-3
次のコードを音読せよ
#+BEGIN_SRC C
  if ((falloc(SMRHSHSCRTCH, S_IFEXT | 0644, MAXRODDHSH)) < 0)
      ...
#+END_SRC
むりむり．
** 式と文
*** 構造がわかるようにインデントしよう
*** 自然な形の式を使おう
否定が入っていると分かりづらくなるのでなるべく避ける
*** 括弧を使ってあいまいさを解消しよう
見かけは
if (x&MASK == BITS)
と書いてあっても，
実際には
if (x & (MASK == BITS))
と評価されてしまう．
意図を正しく伝えるために括弧を書けば，これを避けられる．
*** 複雑な式は分割しよう
式の構文や演算子が充実しているからといって，調子にのって短く書きすぎるな．
#+BEGIN_SRC C
  ,*x += (*xp = (2*k < (n-m) ? c[k+1] : d[k--])); /* いくら正しくても，理解しにくい */

  /* こう書けば，わかりやすい */
  if (2*k < n-m)
      ,*xp = c[k+1];
  else
      ,*xp = d[k--];
  ,*x += *xp;
#+END_SRC
*** 明解に書こう
明快さは，短さと同義ではない．
明解に書いた結果，コードは短くなることもあれば，長くなることもある．
*** 副作用に注意
++など，副作用を持った演算子には注意が必要．
表示と，値の更新が同時に実行されるとは限らないため．
str[i++] = str[i++] = '';
と，多重代入するのは危険．
おとなしく2回に分けて，
str[i++] =  '';
str[i++] =  '';
と書くべき．
scanf("%d %d", &yr, &profit[yr]);
も，意図した結果になることは決してない．
コンパイルした段階で全ての値が評価されるので，profit[yr]はscanfで読み込む前の古いyrの値を使う．
**** 問題1-4
次のそれそれのコードを改良せよ
#+BEGIN_SRC C
  /* 改良前 */
  if (!(c == 'y' || c == 'Y'))
      return;
  /* 改良後 */
  if ((c != 'y' && c != 'Y'))
      return;

  /* 改良前 */
  length = (length < BUFSIZE) ? length : BUFSIZE;
  /* 改良後 */
  if (length < BUFSIZE)
      length = length;
  else
      length = BUFSIZE;

  /* 改良前 */
  flag = flag ? 0 : 1;
  /* 改良後 */
  if (flag != 0)
      flag = 1;

  /* 改良前 */
  quote = (*line == '"') ? 1 : 0;
  /* 改良後 */
  if (*line == '"')
      isquote = 1;
  else
      isquote = 0;

  /* 改良前 */
  if (val & 1)
      bit = 1;
  else
      bit = 0;
  /* 改良後 */
  if (val == 0)
      bit = 0;
  else
      bit = 1;
#+END_SRC
**** 問題1-5
次の部分の問題点は何か
#+BEGIN_SRC C
  int read(int *ip) {             /* ipがまだ代入されていないうちにポインタが呼ばれていることが問題 */
      scanf("%d", ip);
      return *ip;
  }

  insert(&graph[vert], read[&val], read(&ch));
#+END_SRC

**** 問題1-6
さまざまな評価順によって生成される可能性のある出力をすべて列挙せよ
#+BEGIN_SRC C
  #include <stdio.h>

  int main(void){
      int n = 1;
      printf("%d %d\n", n++, n++);
      return 0;
  }
#+END_SRC
- 1, 2 <- gccではエラーもでた．
- 2, 2
- 2, 3
- 変な値が2つ

** 一貫性と慣用句
*** 一貫性
一貫していれば，準拠するスタイル自体はあまり問題ない（けど，本書のものに従うのが得策）．
複数のif文とelse文が同時に出てくるときには，ブレースを絶対に省略してはいけない．
他人の書いたプログラムを修正するときには，そのプログラムのスタイルに従うこと．
いくら気に入っていても，自分のスタイルを使ったりしないように．

*** 慣用句
慣習に従えば，慣習に従っていないところが目立ちやすくなる．
そこがトラブルの兆候を示しているケースはよくある．

例えば，ループの慣用形式は以下．
for (i = 0; i < n; i++)
    array[i] = 1.0;

リストをたどるなら
for (p = list; p != NULL; p = p->next)

do-whileはバグの絶好のすみかになりやすい．
do-whileでないとならない時以外，絶対に使わないこと．

**** getsは絶対に使ってはならない                          :BeyondMyLevel:
セキュリティの問題につながる

**** 多分岐の判定にはelse ifを使おう
*if文がネストされてならんでいるのは，具合の悪いプログラムの兆候！*

**** case文で落下シーケンスを使うのはやめよう．
各ケースはみなbreakで終わるのが基本．
落下を使うのが許されるのは，数個のcaseに全く同一のコードが使われる時．
#+BEGIN_SRC C
case '0':
case '1':
case '2':
    ...
    break;
#+END_SRC
コメントは一切いらない．

**** 問題1-7
以下のC/C++のコードをもっと明快に書き直せ．
***** コード1
****** Before
#+BEGIN_SRC C
  if (istty(stdin)) ;
  else if (istty(stdout)) ;
       else if (istty(stderr)) ;
            else return(0);
#+END_SRC

****** After
#+BEGIN_SRC C
  if (istty(stdin)) {

  } else if (istty(stdout)) {

  } else if (istty(stderr)) {

  } else {
      return(0);
  }
#+END_SRC
***** コード2
****** Before
#+BEGIN_SRC C
  if (retval != SUCCESS)
  {
      return (retval);
  }
  /* All went well! */
  return SUCCESS;
#+END_SRC
****** After
#+BEGIN_SRC C
  if (retval == SUCCESS) {
      retval = SUCCESS;
  }
  return retval;
#+END_SRC
***** コード3
****** Before
#+BEGIN_SRC C
  for (k = 0; k++ < 5; x += dx)
  scanf("%lf", &dx);
#+END_SRC
****** After
#+BEGIN_SRC C
  for (k = 0; k < 5; k++) {
      scanf("%lf", &dx);
      x += dx;
  }
#+END_SRC

**** 問題1-8
次のJavaコードの間違いを見つけて，慣用句的なループを使って書き直せ．
***** Before
#+BEGIN_SRC java
  int count = 0;
  while (count < total) {
      count++;
      if (this.getName(count) == nametable.userName()) {
          return (true);
      }
  }
#+END_SRC
***** After
#+BEGIN_SRC java
  int count = 0;
  while (this.getName(count) != nametable.userName()) {
      count++;
  }
#+END_SRC
** 関数マクロ
*** 関数マクロはなるべく使うな！
短所が長所を上回ってしまっている
関数マクロの定義の中で，パラメータが2回出てくるとき（下の例のc）に，悪夢が起こる．
#+BEGIN_SRC C
# define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#+END_SRC
このisupperが以下のような文脈で呼ばれると大変．
#+BEGIN_SRC C
while (isupper(c = getchar()))
#+END_SRC
そもそもgetchar()などはネストしない方がいい．
*** マクロの本体と引数は括弧に入れよう．
マクロはただのテキスト置換なので，括弧を使っておかないと数学的におかしいことになったりする．
#define square (x) (x) * (x)
と書いたあとで，
1 / square(x)
として使用すると，
1 / (x) * (x)
となる．恐ろしい．
正しくは，
#define square (x) ((x) * (x))
ちゃんと書いたとしても，多重評価の問題は残る．
使わないに越したことはない．

C++なら，インライン関数
*** 問題1-9
次のマクロ定義の問題点を指摘せよ．
#+BEGIN_SRC C
# define ISDIGIT(c) ((c >= '0') && (c <= '9')) ? 1 : 0
#+END_SRC
マクロ内でcが多重評価されている．
例えば，0以上の数が入力されるたびにそれが捨てられ，新しい数が9と比較されることになる．
** マジックナンバー
*** マジックナンバーには名前をつけよう
*** 数値はマクロではなく定数として定義しよう
#defineを使うなということ．
Cのプリプロセッサは強力だが乱暴なツール
マクロはプログラムの字句構造を無残に変更してしまう（どういう意味だろう？）危険なプログラミング手段．
- Cならenum
- C++ならconst
- Javaならfinal
*** 整数ではなく文字定数を使おう
if (c >= 65 && c <= 90)　だと，特定の文字表現方式に完全に依存してしまう．
if (c >= 'A' && c <= 'Z')　のほうがまし．

一番いいのは， if (isupper(c)) のように，ライブラリを使うこと．
**** 0の使い方にも注意を払え
0とするのは，本当にリテラルの整数ゼロを意味するときまでとっておけ．
- ゼロのポインタを意図するなら str = 0; ではなく str = NULL;
- ヌルバイトを意図するなら name[i] = 0; ではなく name = '\0'
- 実数のゼロを意図するなら x = 0; ではなく x = 0.0;
*** オブジェクトサイズは言語に計算させよう                  :BeyondMyLevel:
**** 問題1-10
潜在的な間違いを最小限に食い止めるには，次の定義をどのように書き直すべきか．
#+BEGIN_SRC C
#define FT2METER  0.3048
#define METER2FT  3.29084
#define MI2FT     5280.0
#define MI2KM     1.609344
#define SQMI2SQKM 2.589988
#+END_SRC
多分，#defineではなく，enumを使えということだと思う．
** コメント
*** 削除すべきコメント
- コードを見ればひと目でわかることをわざわざ書いている
- コードと矛盾している
- 見た目に凝りすぎて読み手の注意を削いでしまう

*** どんなときにコメントを書くべきか
- 関数
- グローバル変数
- 定数定義
- 構造体とクラスのフィールド

そのほか，
- アルゴリズムが難解
- データ構造が入り組んでいる
など，コードが（うまく書いてあるけど）本当の意味で難解なときには，コメントがあると有効．
こんなときに書いたほうがいい内容は
- 使われるデータ
- アルゴリズムの性能
- 元のアルゴリズムの修正
- 参考文献
など．

*** 教訓
優れたコードは，悪いコードに比べてコメントが少なくて済む．
**** 悪いコードはコメントをつけるのではなく，コード自体を書き直せ
- 否定演算はわかりにくい
- 役に立たない変数名

**** コードと矛盾させるな
書かれたまんまほったらかしで，コードの内容と矛盾しているコメントが最悪．
- 誤解のもと
- デバック作業が長引く

**** コードと一致させるだけでなく，コードに沿わせろ
「なぜここにそのコードを書く必要があるのか」を書け

**** 問題 1-11
以下のコメントについてコメントせよ．

***** before
#+BEGIN_SRC java
  void dict::insert(string& w)
  // w が辞書にあれば1を，なければ0を返す

  if (n > MAX || n % 2 > 0 )  // 偶数のテスト

  // メッセージを出力
  // 1行出力するたびに行カウンタを加算

  void write_message()
  {
      // カウンタをインクリメント
      line_number = line_number + 1;
      fprintf(fout, "%d %s\n%d %s\n%d %s\n",
              line_number, HEADER,
              line_number + 1, BODY,
              line_number + 2, TRAILER);
      // 行カウンタをインクリメント
      line_number = line_number + 2
  }
#+END_SRC

- 何をするためのコードなのか，全然わからない
- インクリメントが + 1だったり+2だったり，本当にこれでいいのかわからない．
- 「メッセージを出力」はいらない

***** TODO after
Javaがわからないのでなんとも．
#+BEGIN_SRC java
  void dict::insert(string& w)
  // w が辞書にあれば1を，なければ0を返す

  if (n > MAX || n % 2 > 0 )  // 偶数のテスト

  // メッセージを出力
  // 1行出力するたびに行カウンタを加算

  void write_message()
  {
      // カウンタをインクリメント
      line_number = line_number + 1;
      fprintf(fout, "%d %s\n%d %s\n%d %s\n",
              line_number, HEADER,
              line_number + 1, BODY,
              line_number + 2, TRAILER);
      // 行カウンタをインクリメント
      line_number = line_number + 2
  }
#+END_SRC
** なぜ手間をかけるのか
バグの温床になるから．
きれいなコードを書く習慣，頭を整理してよいプログラムを書く習慣が身につくから．
** 参考文献
- "The Elements of Style" by Strunk & White <- 英語の上手な書き方！！
- "プログラム書法" by Brian W. Kernighan <- スタイルの方向性？
- "Writing Solid Code" by Steve Maguire <- プログラミングの参考になる話
- "Code Complete" by Steve McConnell
- "エキスパートCプログラミング: 知られざるCの深層" by Peter van der Linden

* アルゴリズムとデータ構造
プログラムの部品（データ）の作りかた
** 探索
配列がベスト．
ただし，探索関数は配列のサイズを知っていないといけない．
配列の最後にNULLを入れると親切．Lispみたい
** 探索の種類
*** 逐次探索（線形探索）
禁止ワード5個程度を探す状況．
データが少ないときは十分速い．
関数がないか，調べろ．
車輪の再発明はだめ．

*** 二分探索
要素数が100 個を超えるくらいになってきたら，二分探索を検討してもいいかも．
二分探索をするときには，事前に要素を文字順にソートしておかなければならない．
実行時間はlog2(n)．

** ソーティング
二分探索をするためには，ソートが必要といった．
最良の汎用ソーティングアルゴリズムは，クイックソート（Hoare 1960）．

次のコードは，最も単純な実装．
#+BEGIN_SRC C
  /* quicksort */
  void quicksort(int v[], int n)
  {
      int i, last;
      if (n <= 1)                 /*  */
          return;
      swap(v, 0, rand() % n);
      lot = 0;
      for (i = 1; i < n; i++)
          if (v[i] < v[0])
              swap(v, ++last, i);
      swap(v, 0, last);
      quicksort(v, last);
      quicksort(v+last+1, n-last-1);
  }
  /* swap */
  void swap(int v[], int i, int j)
  {
      int temp;
      temp = v[i];
      v[i] = v[j];
      v[j] = temp;
  }
#+END_SRC

#+RESULTS:
このアルゴリズムの中では，2値を入れ替える処理が3回出てくる．
こういう処理は，関数化しよう（swap になっている）．

++last は，前置増分演算子．

クイックソートは，平均して nlogn の速度で動作するが，
外れ値がいくつかあるようなひねくれたデータ分布に対しては，効率が下がったりする．
実装の工夫によって，このようなデータへのパフォーマンスを上げることができる．

** ライブラリ                                                       :難しい:
C と C++ の標準ライブラリには
- 不都合な入力に強い
- 高速
なアルゴリズムで実装されたソート関数がある．
ただし，引数の与え方など，インターフェースについてはライブラリの要求に従わなくてはならない．

*** 問題 2-1
** Java 版クイックソート                                            :難しい:
昔は自分で書かないといけなかったが，後から実装された．
ただし，汎用性のある実装にするには，自分で書くしかない．

Java には関数ポインタがない？
*** 問題 2-2
** O 記法
理論的な速度の比較に便利．
ただし，速度の実測値は，オーバーヘッドなどの枝葉の部分にも左右される．
最も効率が悪いのは指数的アルゴリズム．

巡回セールスマン問題のように，指数的アルゴリズムしか発見されていない場合には，
近似値を見つけるアルゴリズムで代用されることが多い．
*** 問題 2-3
*** 問題 2-4
** 配列の伸長                                                       :難しい:

** リスト                                                           :難しい:
C++ と Java はリストをサポートしているが，C の場合には自分で書かねばならない．

使い所
- 項目の集合が頻繁に変化するとき
- 事前に項目数がわからないとき

明示的に list 型を宣言するのではなく，
- name
- value
- 次の要素へのポインタ
を持った，数珠つなぎ可能な要素を作る．

要素の追加は，もちろん先頭への追加が一番速い．
末尾への追加は，末尾を見つける必要があるため，O(n) の手順となってしまう．
末尾への追加をどうしても高速化したければ，リストの末尾を指すポインタを各要素に持たせればいいが，シンプルさは失われる．

リストにはバイナリサーチは使えない．

リストの長さを計算するのもなかなか大変だが，apply 関数を書くとうまくできる．
#+BEGIN_SRC C
  /* apply: listp の個々の要素に fn を実行 */
  void apply(Nameval *listp,
             void (*fn)(Nameval*, void*), void *arg)
  {
      for ( ; listp != NULL; listp = listp->next)
          (*fn)(listp, arg);      /* 関数を呼び出す */
  }
#+END_SRC


** ツリー
ツリーとは
- それぞれの項目が値を持つ
- ゼロ個以上の他の項目を指す（少なくともNULLを指す）
- 他の「1個だけ」の項目によって指される
ただし，ルートは例外．

別の要素を指すポインタが複数存在するので，
リストや配列だとO(n)の時間がかかる多くの処理が，ツリーなら O(logn)で済むようになる．

左右の子ノードの大小関係を一貫させておけは，
新しいノードをリンクするのにふさわしい場所を効率的に見つけることができる．

リストと違い，ツリーの場合には，重複テストの実行コストがほとんどないため，基本的に重複は排除した方がいい．
ただし，アプリケーションの目的によっては重複を許すことになるかもしれない．
ルートからリーフまでの個々の経路の長さが同じツリーを，「バランス木」という．
項目の検索は実質バイナリサーチになるので，作業はO(logn)の速さで完了する．

*** lookup 関数を定義する
#+BEGIN_SRC C
  /* lookup: ツリーtreepで名前をルックアップ */
  Nameval *lookup(Nameval *treep, char *name)
  {
      int cmp;

      if (treep == NULL)
          return NULL;
      cmup = strcmp(name, treep->name);
      if (cmp == 0)
          return treep;
      else if (cmp < 0 )
          return lookup(treep->left, name);
      else
          return lookup(treep->right, name);
  }
#+END_SRC

*** nrlookup 関数を定義する

出てきた用語
- 間順走査
- 後順走査
- 前順走査



*** 問題 2-11

*** 問題 2-12

*** 問題 2-13
** ハッシュテーブル

** まとめ

** 参考文献
* 設計と実装
データ構造は，プログラム開発の中心をなす決断．
データ構造が決まればアルゴリズムが決まり，コーディングも楽．
言語の違いもあまりない．

ここでは例として，ある程度まともな英文をランダムに生成するプログラムを作る．
文章構造を意識した統計モデルは，どうやって作ればいいだろうか？

部品を組み合わせてプログラムを作る方法
** マルコフ連鎖アルゴリズム
** データ構造の選択
** C によるデータ構造の作成
** 出力の生成
** Java
** C++
** Awk と Perl
** 性能
** 教訓
プログラムの全体像を決めるのはデータ構造．
ただし，設計を完全に終えてから実装することはできない．
現実のプログラムの作成には，反復と実験が伴う．（研究と同じだなぁ）
製品としてのクオリティを実現するためには，多大な労力が必要．
*** 問題 3-8
** 参考文献
* インターフェイス
目標と制約との間でのトレードオフこそが，設計の真髄．
まして他人も使うプログラムの場合，トレードオフの判断はさらに広範な影響を及ぼす．
設計で解決すべき課題は
- インターフェース
- 情報の遮蔽
- リソース管理
- エラー処理

ここまでで部品の作りかた（アルゴリズムとデータ構造），部品の組み合わせ方（設計と実装）を見てきたので，
本章では，開発者が同一人物とは限らないコンポーネント同士のインターフェースに目を向ける．

設計中というのは膨大な数の判断が無意識になされることが多いので，
原則を押さえておかないと行き当たりばったりのインターフェースが出来上がってしまう．
* デバッグ
ここまで，かなりの量のコードを書いてきたが，最初からすんなり動いたわけではない．
プログラムの複雑度は，コンポーネント同士の対話の多様性の度合いに比例する．
コンポーネント間の接点を減らすテクニックはいくつかあるが，結局にはテストとデバッグを繰り返すに尽きる．

デバッグ時間の短縮に有効なものには，
- 優れた設計
- 優れたスタイル
- 境界条件テスト
- コード中での診断と正常性チェック
- 防御的プログラミング
- 設計の優れたインターフェース
- グローバルデータの限定的な使用
- 検査用ツール

なぜいろいろな言語が存在するのか？
バグを減らすため，というのも一つの見方．
バグを減らすのに有効な機能は
- 添字の範囲チェック
- ポインタ使用上の制約
- ポインタそのものが存在しないこと
- ガベージコレクション
- 文字列データ型
- 型つきI/O
- 強い型チェック

間違いを増やしやすい機能
- goto文
- グローバル変数
- 使用上の制約のないポインタ
- 自動型変換

高級な言語は単純なバグを減らすかもしれないが，その分高級なバグが増える．

本章では，デバッグ時間を削減する方法を紹介する．
* テスト
テストはデバッグとは違う．
優れた構文で自ずとプログラムが正しく作られるとする意見もあるが，まだ現実的ではない．
テストを系統的に実行すれば，プログラム開発スタートからずっと，正しいまま成長することができる．
手作業を追放するのにも役立つ．

コードジェネレータもバグ撲滅に貢献するが，これは第9章で扱う．

本章は，あくまでもテスト．
* 性能
速度向上にも心を配る必要がある．ただしそれは，正しさと堅牢性を保ちながら，というのが条件．
第1の原則は，「最適化するな」．

使い捨てコードに速度は必要ない．
しかし，何度も使われるプログラムや中枢を担うプログラムでは，速度が重要．

最善の戦略は，作業目的に合致した最も単純明快なアルゴリズムとデータ構造を選択すること．
速度向上を考えるのはその後．

ツールの使用も重要．そして
- 自動化
- 記録
- 回帰テスト
を維持することも重要．
* 移植性
移植性がなぜ重要なのか
- 汎用的になるように設計すれば，将来的にはメンテナンスの手間が減るし，有用性も増すから
- コンパイラやOSの変化で，機能が変化してしまうかもしれない．特殊な機能に依存する度合いが低いほど，プログラムが破綻する可能性も低くなるから
- 移植性を高めるために投下される労力のおかげで，設計と構造も向上するし，より徹底的にテストされるから
このように，移植性は，優れたプログラミングと深く関連している．

現実に応じて移植性の度合いは加減を付ける必要はあるが，
努力は，ソフトウェアの更新のときに報われる．

重要なのは，
- ソフトウェア開発の際には，準拠すべき条件の枠内で動作するよう心がけること
- 特殊なコードを追加して個々の移植性の問題を解決しないこと
- 移植性のないコードを使わないといけないときには，抽象化とカプゼル化によって限定し，制御すること

* 記法
プログラムの書きやすさは，言語の選択によっても変わってくる．
コードが多すぎると感じたら，言語の選択が間違っているのかもしれない．

本章では，記法によってどのように問題を解決できるかを説明し，
独自の言語を開発するときに利用できる代表的なテクニックを紹介する．
