#+TITLE: Land of Lisp
* 第13章 Webサーバを作ろう！！
Webベースのゲームを作るためにここがある．
さっと読んで終わり．必要なら，またあとから戻ってこよう．
[2018-11-22 Thu]
** Common Lispでのエラー処理
** ゼロからWebサーバを書く
文字のデコード方法
日本語のデコードはやはり特殊（訳注）
安全のためにはreadでなくinternを使え
* 第15章 ダイス・オブ・ドゥーム: 関数型スタイルでゲームを書こう
Webベースのゲームを作るためにここがある．
** 15.1 ダイス・オブ・ドゥームのルール
** 15.2 ダイス・オブ・ドゥームのゲーム例
** 15.3 ダイス・オブ・ドゥームの実装，バージョン1
*** いくつかのグローバル変数
プレーヤーの数，ボードのサイズなど
*** ゲーム盤の表現
関数型（関数スタイルの条件に当てはまる書き方）で書かれた部分と，
そうでない（汚れ仕事を引き受ける）部分の違いを明確にして，説明されている．
乱数を使用していたり，画面に表示するものは，汚れ仕事に分類されるようだ．
*** ダイス・オブ・ドゥームのルールをゲームの他の部分から分離する
このゲームは，
- 人間の指し手を処理する部分
- AIプレーヤ
- ルールエンジン
の3つの部分に分けて設計するのが合理的．
関数プログラミングを使えは，この設計ができる．
一方，命令型でプログラミングしてしまうと，どうしてもルールに関する部分に重複が生じる．
*** ゲームツリーの生成
defun game-tree
*** 相手に手番を渡す
defun add-passing-move
*** 攻撃の手を計算する
defun attacking-moves
cur-playerってなんだろう？
難しい！！
*** 隣接するマスを見つける
defun neighbors
*** 攻撃
defun board-attack
ルールに従って実装する．
今の所，わかりやすさを重視して，効率の悪い実装になっている．
今後，バージョンを重ねるにつれて，この欠点を改善していく．
*** 補給
defun add-new-dice
ともすれば関数型の掟を破ることになりそうな動作だが，
ローカルに再帰関数を定義することによって，関数型で書く．
*** game-tree関数を試す．
ここまででこのゲームの完全なゲーム木をつくるコードが揃った．
ただし，サイズが莫大になるのて，実行には注意すること．
*** 人間対人間でダイス・オブ・ドゥームをプレイする
**** メインループ
defun play-vs-human
再起呼び出し
**** ゲームの状態を表示する
defun print-info
**** 人間のプレーヤからの入力を処理する
defun handle-human
**** 勝者を決定する
defun winners
**** 人間対人間のダイス・オブ・オブ・ドゥームを遊んでみよう
** 15.4 コンピュータによる対戦相手を作る
ゲーム木の生成を独立させたので，AIプレーやのコードを追加するだけでいい．
アルゴリズムは，
- 可能な手それぞれについて，
- その手を指すことで生じる盤面の状態に点数をつけ，
- 最も高い点数の手を選ぶ．
しかし，次の1手で勝敗が決まることはまれなので，どうやって点数をつければいいのだろう．
この手を打てば相手はこう打って...と，再帰の袋小路に入ってしまう．
*** ミニマックスアルゴリズム
<<ミニマックスアルゴリズム>>: 相手にとって一番いい手とは，自分にとって最も悪い手である．
*** ミニマックスをコードにする
defun rate-position
*** AIプレーヤを使うゲームループ
defun handle-computer
*** 人間対コンピュータで対戦してみよう
defun play-vs-computer
handle-humanとhandle-computerを交互に呼ぶ．
** 15.5 ダイス・オブ・ドゥームを高速化する
関数型スタイルで書くと，初心者のうちはどうしても遅いコードになりがち．
高速化に，以下のテクニックが役立つ
*** クロージャ
Lispプログラミングで重要な概念．
<<クロージャ>>: lambdaで関数が作られる時に，外側の情報を補足したもの．

第2章で，letを使って変数を作られる変数は，必ずしもローカルではないといった．
例えば，let式で作られた変数が外側で参照されているとき，値は残る．
Lispがガベージコレクタを備えているので，これが起こる．
これを使えば，関数の呼び出し「間」でも，明示的な代入なしに値を保持しておくことが可能（p.329参照）．
*** メモ化
関数が受け取った引数と，その結果を記録しておけば，同じ引数でまた呼ばれたときに，再計算の必要がない．
**** neighbors関数をメモ化する
neighbors関数をカスタムする．
もとのneighbors関数うold-neighborsというレキシカル変数に保存．
その後で，メモ化機能をつけた新しいneighborsを定義する．
この関数の動作は
- その計算が初めてではなかったときには，再計算せず，単にハッシュテーブルの値を表示する．
- その計算が初めてだったら，もとのneighbors関数を呼んで，計算する．
というもの．
**** ゲーム木をメモ化する
ここでも，もとのgame-tree関数をold-game-treeとしてレキシカル変数に保存し，カスタムしている．
コードはneigbors関数のカスタムとほとんど同じだが，eqlではなくequalpを使っていることろだけ違う．
これは，この関数が引数として配列をとるものだから．
equalpは配列の完全一致を調べる．
**** rate-position関数をメモ化する
ここでもold-rate-positionを作ってメモ化．
ただし，tree引数はゲーム木なので，巨大なデータである可能性がある．
そこで，treeとplayerを別々に記録し，treeの方はgame-treeのメモ化を
*** 末尾呼び出し最適化
いくらコンピュータでも，あとで1を足せ，という処理を10000回分も覚えておくことは辛い（クラッシュするかも）．
BASICのGOTOやCのlongjmpみたいなもの．
**** Common Lispでの末尾呼び出しのサポート
末尾呼び出しがサポートされていないこともある．
CLISPでは，コンパイルすることによって有効になる．
**** ダイス・オブ・ドゥームでの末尾呼び出し最適化
add-new-dice関数([[*%E8%A3%9C%E7%B5%A6][「補給]]」参照)を，末尾呼び出しを使って書き直す．
*** 3×3のゲーム盤でのプレイ例
コンピュータはかなり強い．
** 本章で学んだこと
- 関数型プログラミングを使うことで，ルールエンジンを独立させて開発できた．
- AIプレーヤは，[[ミニマックスアルゴリズム]]を使ってプログラムするのが効率的．
- レキシカル変数（これまで，ローカル変数と呼んでいた）は，lambda式の中で参照されていると，式の外側でも生き続けることができる．このように変数を作ることを，[[「クロージャ]]を作る」という．
- 関数型プログラムの高速化には，以下のテクニックが有効．
  - メモ化
  - 末尾呼び出し最適化
* 索引で調べた関数
** let p.16, 133, 340
ローカル変数
** 1-
引数から1を引いた数を返す
