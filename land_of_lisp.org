#+TITLE: Land of Lisp
#+TAGS: cannot beyond important
* Lambda: とても大事な関数なので特別に章を分けて説明しよう
** lambdaがすること
名前をつけずに関数を作れる．
その場限りの処理を他の関数に渡したい時にぴったり．
*** 普通に作ると名前が必要
#+BEGIN_SRC elisp
  (defun half (n)
    (/ n 2))

  (half 6)
#+END_SRC

#+RESULTS:
: 3
*** lambdaを使うと名前もdefunもいらない
#+BEGIN_SRC elisp
  ((lambda (n) (/ n 2)) 10)
#+END_SRC

#+RESULTS:
: 4
*** mapcarに渡して使う
#+BEGIN_SRC elisp
  (mapcar (lambda (n) (/ n 2)) '(2 4 6))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
** lambdaがそんなに大事なわけ
Lispのアイデアそのものが生まれた中心にある概念だから．
Lispの他の関数も，lambdaの概念を元に導かれている．
** 本章で学んだこと
- lambdaを使って，名前を与えることなしに関数を作れる．
- Lispの多くの関数は，関数を引数として受け取れる．これらの関数を使うことを，「高階プログラミング」と呼ぶ．
* Webサーバを作ろう！！
Webベースのゲームを作るためにここがある．
さっと読んで終わり．必要なら，またあとから戻ってこよう．
[2018-11-22 Thu]
** Common Lispでのエラー処理
** ゼロからWebサーバを書く
文字のデコード方法
日本語のデコードはやはり特殊（訳注）
安全のためにはreadでなくinternを使え
* ダイス・オブ・ドゥーム: 関数型スタイルでゲームを書こう
Webベースのゲームを作るためにここがある．
** ダイス・オブ・ドゥームのルール
** ダイス・オブ・ドゥームのゲーム例
** ダイス・オブ・ドゥームの実装，バージョン1
*** いくつかのグローバル変数
プレーヤーの数，ボードのサイズなど
*** ゲーム盤の表現
関数型（関数スタイルの条件に当てはまる書き方）で書かれた部分と，
そうでない（汚れ仕事を引き受ける）部分の違いを明確にして，説明されている．
乱数を使用していたり，画面に表示するものは，汚れ仕事に分類されるようだ．
*** ダイス・オブ・ドゥームのルールをゲームの他の部分から分離する
このゲームは，
- 人間の指し手を処理する部分
- AIプレーヤ
- ルールエンジン
の3つの部分に分けて設計するのが合理的．
関数プログラミングを使えは，この設計ができる．
一方，命令型でプログラミングしてしまうと，どうしてもルールに関する部分に重複が生じる．
*** ゲームツリーの生成
defun game-tree
*** 相手に手番を渡す
defun add-passing-move
*** 攻撃の手を計算する
defun attacking-moves
cur-playerってなんだろう？
難しい！！
*** 隣接するマスを見つける
defun neighbors
*** 攻撃
defun board-attack
ルールに従って実装する．
今の所，わかりやすさを重視して，効率の悪い実装になっている．
今後，バージョンを重ねるにつれて，この欠点を改善していく．
*** 補給
defun add-new-dice
ともすれば関数型の掟を破ることになりそうな動作だが，
ローカルに再帰関数を定義することによって，関数型で書く．
*** game-tree関数を試す．
ここまででこのゲームの完全なゲーム木をつくるコードが揃った．
ただし，サイズが莫大になるのて，実行には注意すること．
*** 人間対人間でダイス・オブ・ドゥームをプレイする
**** メインループ
defun play-vs-human
再起呼び出し
**** ゲームの状態を表示する
defun print-info
**** 人間のプレーヤからの入力を処理する
defun handle-human
**** 勝者を決定する
defun winners
**** 人間対人間のダイス・オブ・オブ・ドゥームを遊んでみよう
** コンピュータによる対戦相手を作る
ゲーム木の生成を独立させたので，AIプレーやのコードを追加するだけでいい．
アルゴリズムは，
- 可能な手それぞれについて，
- その手を指すことで生じる盤面の状態に点数をつけ，
- 最も高い点数の手を選ぶ．
しかし，次の1手で勝敗が決まることはまれなので，どうやって点数をつければいいのだろう．
この手を打てば相手はこう打って...と，再帰の袋小路に入ってしまう．
*** ミニマックスアルゴリズム
<<ミニマックスアルゴリズム>>: 相手にとって一番いい手とは，自分にとって最も悪い手である．
*** ミニマックスをコードにする
defun rate-position
*** AIプレーヤを使うゲームループ
defun handle-computer
*** 人間対コンピュータで対戦してみよう
defun play-vs-computer
handle-humanとhandle-computerを交互に呼ぶ．
** ダイス・オブ・ドゥームを高速化する
関数型スタイルで書くと，初心者のうちはどうしても遅いコードになりがち．
高速化に，以下のテクニックが役立つ
*** クロージャ
Lispプログラミングで重要な概念．
<<クロージャ>>: lambdaで関数が作られる時に，外側の情報を補足したもの．

第2章で，letを使って変数を作られる変数は，必ずしもローカルではないといった．
例えば，let式で作られた変数が外側で参照されているとき，値は残る．
Lispがガベージコレクタを備えているので，これが起こる．
これを使えば，関数の呼び出し「間」でも，明示的な代入なしに値を保持しておくことが可能（p.329参照）．
*** メモ化
関数が受け取った引数と，その結果を記録しておけば，同じ引数でまた呼ばれたときに，再計算の必要がない．
**** neighbors関数をメモ化する
neighbors関数をカスタムする．
もとのneighbors関数うold-neighborsというレキシカル変数に保存．
その後で，メモ化機能をつけた新しいneighborsを定義する．
この関数の動作は
- その計算が初めてではなかったときには，再計算せず，単にハッシュテーブルの値を表示する．
- その計算が初めてだったら，もとのneighbors関数を呼んで，計算する．
というもの．
**** ゲーム木をメモ化する
ここでも，もとのgame-tree関数をold-game-treeとしてレキシカル変数に保存し，カスタムしている．
コードはneigbors関数のカスタムとほとんど同じだが，eqlではなくequalpを使っていることろだけ違う．
これは，この関数が引数として配列をとるものだから．
equalpは配列の完全一致を調べる．
**** rate-position関数をメモ化する
ここでもold-rate-positionを作ってメモ化．
ただし，tree引数はゲーム木なので，巨大なデータである可能性がある．
そこで，treeとplayerを別々に記録し，treeの方はgame-treeのメモ化を
*** 末尾呼び出し最適化
いくらコンピュータでも，あとで1を足せ，という処理を10000回分も覚えておくことは辛い（クラッシュするかも）．
BASICのGOTOやCのlongjmpみたいなもの．
**** Common Lispでの末尾呼び出しのサポート
末尾呼び出しがサポートされていないこともある．
CLISPでは，コンパイルすることによって有効になる．
**** ダイス・オブ・ドゥームでの末尾呼び出し最適化
add-new-dice関数([[*%E8%A3%9C%E7%B5%A6][「補給]]」参照)を，末尾呼び出しを使って書き直す．
例として，リストの長さを求める簡単な関数を作ってみる．
***** my-length
****** 関数を書く
#+BEGIN_SRC elisp
  (defun my-length (lst)
    (if lst
        (1+ (my-length (cdr lst)))
      0))
#+END_SRC

#+RESULTS:
: my-length
****** 関数を使ってみる
長さが3のリストを渡すと，ちゃんと3と返ってきた．

#+BEGIN_SRC elisp
  (my-length '(fie foh fum))
#+END_SRC
#+RESULTS:
: 3

****** しかし，大きいデータを渡してしまうと...?
上のアルゴリズムでは，リストを全て調べ終わるまで1を足しておくことをメモリを使って覚えておく必要がある．
大きいリストを渡すと，オーバーフローしてしまう．
なぜか?
上のmy-lengthの定義では，自身の再帰呼出しが3行目に来ている．
これを，最後に持っていくとメモリに優しい．
****** そこで，末尾呼び出しで書く！
ローカル関数fが必要になるが，再帰呼出しを一番最後に移動させることができた．
#+BEGIN_SRC elisp
  (defun my-length (lst)
    (labels ((f (lst acc)
                (if lst
                    (f (cdr lst) (1+ acc))
                  acc)))
      (f lst 0)))
#+END_SRC

#+RESULTS:
: my-length
****** 末尾呼び出しバージョンを使ってみる
この環境じゃ違いがわからないけど...
#+BEGIN_SRC elisp
  (my-length '(fie foh fum))
#+END_SRC

#+RESULTS:
: 3

*** 3×3のゲーム盤でのプレイ例
コンピュータはかなり強い．
** 本章で学んだこと
- 関数型プログラミングを使うことで，ルールエンジンを独立させて開発できた．
- AIプレーヤは，[[ミニマックスアルゴリズム]]を使ってプログラムするのが効率的．
- レキシカル変数（これまで，ローカル変数と呼んでいた）は，lambda式の中で参照されていると，式の外側でも生き続けることができる．このように変数を作ることを，[[「クロージャ]]を作る」という．
- 関数型プログラムの高速化には，以下のテクニックが有効．
  - メモ化
  - 末尾呼び出し最適化
* マクロの魔法
** 簡単なLispマクロ
このコードを書くのは，何度目だろう...となったら，マクロ化のチャンスかも（ホントは関数化を先に考える）．
括弧を減らすことができるかも．
*** マクロの展開
マクロは普通の関数と違い，コンパイルされるときに走る．このタイミングを「マクロ展開時」という．
普通の関数が走るタイミングは，普通に「実行時」と呼ぶ．
*** マクロはどんなふうに変換されるか
(defmacro macroname (var val &body body))
&bodyは，「自分よりも右に出てくる式は全部リストにしてbodyとして渡してくれ」という意味．
*** 簡単なマクロを使ってみる
マクロのデバッグ方法は
(macroexpand '(macro ...))
みたいな感じ．
** もっと複雑なマクロ
冗長だった[[*my-length][my-length]]関数を，マクロを使って書き直す
my-lengthを再掲し，冗長なポイントにコメントをつけてみた．
#+BEGIN_SRC elisp
  (defun my-length (lst)
    (labels ((f (lst acc)                 ;ローカル関数を定義する
                (if lst                   ;リストが空かどうか調べる
                    (f (cdr lst) (1+ acc)) ;cdrでリストの残りを調べる
                  acc)))
      (f lst 0)))

  (my-length '(foo bar ping pong))
#+END_SRC

#+RESULTS:
: 4
マクロを使って，my-lengthを引き締めよう．
*** リストを分割するマクロ
**** まずsplit関数を作る
#+BEGIN_SRC elisp
;;バグ有り注意
  (defmacro split (val yes no)
    `(if ,val
         (let ((head (car ,val))
               (tail (cdr ,val)))
           ,yes)
       ,no))

  (split '(2 3)
         (format "Split to ~a and ~a." head tail)
         (format "Cannot be split."))
#+END_SRC
, 
#+RESULTS:
: Split to ~a and ~a.
split関数は，headとtailという変数を作り出し，これらは関数の外からも参照できる．
このように，自動的に変数を作り出すマクロは，<<アナフォリックマクロ>>と呼ばれる．

*** マクロ中で式が繰り返し実行されるのを防ぐ
**** 意図しない繰り返し
以下のコードは，"Lisp rocks!"が3回出てくる．
これは，progn式がval引数にまるごとわたってくるため．
#+BEGIN_SRC elisp
  (split (progn (princ "Lisp rocks!")
                '(2 3))
         (format "OK" head tail)
         (format "NG"))
#+END_SRC
**** ローカル変数を定義して多重呼び出しを回避
splitの定義を以下のようにすれば，一応princは1回しかよばれなくなる． |
#+BEGIN_SRC elisp
  ;;; しかしまだバグがある
  (defmacro split (val yes no)
    `(let1 x ,val
           (if x
               (let ((head (car x))
                     (tail (cdr x)))
                 ,yes)
             ,no)))
#+END_SRC
ここで残っているバグは，なんだろうか？
*** 変数補足を避ける
(gensym)を使うんだ．
*** 再帰呼び出しマクロ
再帰呼び出しを含むrecurseマクロを定義して完成．
まずpairs関数を作り，それを使ってrecurseマクロを書く．
** マクロの危険と代替案
確かに強力だが，アドホックすぎる．
それに，他人（そして未来の自分も？）がコードを読みにくい．
初心者がマクロを書きたいと思うとき，たいていは関数型プログラミングで実現できることが多い．
ただし，どうしても関数型プログラミングでは無理な状況も確かにある．
マクロは，そんなときの最後の手段．
** 本章で学んだこと
- マクロを使うと，コードを書くコードを書ける．マクロによって，自分独自の言語を作り，それをLispコンパイラが見る直前に標準のLispへと変換することができる．
- マクロを使えば，コードを書く時のデジャヴを避けることができる．
- マクロを書く時は，１つのコードが意図せず複数回実行されないよう，気をつけよ．
- マクロを書く時には，意図しない変数補足を起こさないよう，気をつけよ．gensymで名前を作れば，それを避けられる．
- マクロ内で作る変数を，仕様として敢えてマクロ使用者からも見えるようにしている時，そのマクロはアナフォリックマクロと呼ばれる．
- マクロプログラミングは強力だが，最後の手段と心得よ．可能な限り関数型プログラミングで実装せよ．
* ドメイン特化言語
** ドメインとは何か
人が考えを及ぼす領域．
これから，
- ベクター画像を作る
- ゲームのコマンドを作る
という，全く異なるドメインにおいて，それぞれDSLを作成し，どのように役立つかを見ていく．
** SVGファイルを書き出す
htmlみたいなタグ言語．
Web開発者ではホットな形式．
*** タグマクロを使ってXMLとHTMLを生成する
タグを自動生成するマクロがあったら便利．
LaTeXの表作成にも使えるのではないか．
**** マクロの補助関数を書く
**** tagマクロを作る
以下の要件を満たすには，どうしてもマクロが必要．
- ネストしたタグを完璧に作りたい
- タグ名と属性名は常にデータモードでいい

入れ子のタグも生成することができた．
**** tagマクロを使ってHTMLを生成する
HTMLも楽勝．
*** SVG特有のマクロと関数を作る
SVGには2つの特別な属性が必要．
- xmlns属性．ビューワで正しく表示するための属性．
- xmlns:xlink属性．画像の中にハイパーリンクを置くための属性．
マクロが必要な部分と，関数で十分な部分がある．
*** もっと複雑なSVG画像を描く
ランダムウォークのグラフを書いてみた．
マクロの中で生のLispコードでループさせることもできる．
** 魔法使いのアドベンチャーゲームに新たなコマンドを追加する
コードは
http://landoflisp.com から wizard_game.lisp をダウンロード．
*** ゲームコマンドを直接定義する
**** 溶接のコマンド weld
*chain-welded*という動的変数を定義して実装．
ただし条件がある
- 屋根裏にいる必要がある
- 鎖とバケツを持っている必要がある
- 鎖とバケツはまだ溶接されていない状態でないとだめ
溶接したあとは，*chain-welded*がtになる．
**** 「投げ入れる」コマンド dunk
溶接と同様，いくつか条件がある
- 井戸の前にいる
- 鎖が溶接されたバケツを持っている
- ...
**** さて，一歩引いて見ると
weldとdunkに共通点がある．
これを考慮してgame-actionマクロを書いて，今後新しいコマンドを追加するのを楽にしよう．
game-actionの引数は，
- コマンドの名前
- 必要なアイテム
- 場所
- 任意のコード

ゲームのエンディングの分岐も実装できる．
*** 完成した魔法使いのアドベンチャーゲームをプレーしよう 
** 本章で学んだこと
LispでDSLをどう作るかを学んだ．
- 特定の領域で，その領域に特別なやり方でプログラムを書く場合，マクロは非常に良い道具となる．マクロを使えば，自分のDSLが作れる．
- マクロの前に補助関数（print-tagのような）をまず書いて，次にマクロでないとできない機能を盛り込んだマクロ（tagのような）を書く，というのがいい方法．補助関数に対する改善としてのマクロは，より美しく，安全な構文をプログラマが使えるようにしてくれる．
- DSLと生のLispコードを混ぜて使うことができる．これによってプログラマは多くの力を得る．
- DSLは，Webページを生成するコード，画像を描画するコード，ゲームコマンドを定義するコード，など，何かの目的に特化したコードを書く時に便利だ．
* TODO 遅延プログラミング
* 索引で調べた関数
** let p.16, 133, 340
ローカル変数
** 1-
引数から1を引いた数を返す
